// Code generated by fastssz. DO NOT EDIT.
package service

import (
	ssz "github.com/ferranbt/fastssz"
	"github.com/spacemeshos/poet/shared"
)

// MarshalSSZ ssz marshals the executionState object
func (e *executionState) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(e)
}

// MarshalSSZTo ssz marshals the executionState object to a target array
func (e *executionState) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(33)

	// Field (0) 'NumLeaves'
	dst = ssz.MarshalUint64(dst, e.NumLeaves)

	// Field (1) 'SecurityParam'
	dst = ssz.MarshalUint8(dst, e.SecurityParam)

	// Offset (2) 'Members'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(e.Members); ii++ {
		offset += 4
		offset += len(e.Members[ii])
	}

	// Offset (3) 'Statement'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(e.Statement)

	// Offset (4) 'ParkedNodes'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(e.ParkedNodes); ii++ {
		offset += 4
		offset += len(e.ParkedNodes[ii])
	}

	// Field (5) 'NextLeafID'
	dst = ssz.MarshalUint64(dst, e.NextLeafID)

	// Offset (6) 'NIP'
	dst = ssz.WriteOffset(dst, offset)
	if e.NIP == nil {
		e.NIP = new(shared.MerkleProof)
	}
	offset += e.NIP.SizeSSZ()

	// Field (2) 'Members'
	if len(e.Members) > 1024000 {
		err = ssz.ErrListTooBig
		return
	}
	{
		offset = 4 * len(e.Members)
		for ii := 0; ii < len(e.Members); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += len(e.Members[ii])
		}
	}
	for ii := 0; ii < len(e.Members); ii++ {
		if len(e.Members[ii]) > 1024000 {
			err = ssz.ErrBytesLength
			return
		}
		dst = append(dst, e.Members[ii]...)
	}

	// Field (3) 'Statement'
	if len(e.Statement) > 1024000 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, e.Statement...)

	// Field (4) 'ParkedNodes'
	if len(e.ParkedNodes) > 1024000 {
		err = ssz.ErrListTooBig
		return
	}
	{
		offset = 4 * len(e.ParkedNodes)
		for ii := 0; ii < len(e.ParkedNodes); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += len(e.ParkedNodes[ii])
		}
	}
	for ii := 0; ii < len(e.ParkedNodes); ii++ {
		if len(e.ParkedNodes[ii]) > 1024000 {
			err = ssz.ErrBytesLength
			return
		}
		dst = append(dst, e.ParkedNodes[ii]...)
	}

	// Field (6) 'NIP'
	if dst, err = e.NIP.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the executionState object
func (e *executionState) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 33 {
		return ssz.ErrSize
	}

	tail := buf
	var o2, o3, o4, o6 uint64

	// Field (0) 'NumLeaves'
	e.NumLeaves = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'SecurityParam'
	e.SecurityParam = ssz.UnmarshallUint8(buf[8:9])

	// Offset (2) 'Members'
	if o2 = ssz.ReadOffset(buf[9:13]); o2 > size {
		return ssz.ErrOffset
	}

	// Offset (3) 'Statement'
	if o3 = ssz.ReadOffset(buf[13:17]); o3 > size || o2 > o3 {
		return ssz.ErrOffset
	}

	// Offset (4) 'ParkedNodes'
	if o4 = ssz.ReadOffset(buf[17:21]); o4 > size || o3 > o4 {
		return ssz.ErrOffset
	}

	// Field (5) 'NextLeafID'
	e.NextLeafID = ssz.UnmarshallUint64(buf[21:29])

	// Offset (6) 'NIP'
	if o6 = ssz.ReadOffset(buf[29:33]); o6 > size || o4 > o6 {
		return ssz.ErrOffset
	}

	// Field (2) 'Members'
	{
		buf = tail[o2:o3]
		num, err := ssz.DecodeDynamicLength(buf, 1024000)
		if err != nil {
			return err
		}
		e.Members = make([][]byte, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if len(buf) > 1024000 {
				return ssz.ErrBytesLength
			}
			if cap(e.Members[indx]) == 0 {
				e.Members[indx] = make([]byte, 0, len(buf))
			}
			e.Members[indx] = append(e.Members[indx], buf...)
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (3) 'Statement'
	{
		buf = tail[o3:o4]
		if len(buf) > 1024000 {
			return ssz.ErrBytesLength
		}
		if cap(e.Statement) == 0 {
			e.Statement = make([]byte, 0, len(buf))
		}
		e.Statement = append(e.Statement, buf...)
	}

	// Field (4) 'ParkedNodes'
	{
		buf = tail[o4:o6]
		num, err := ssz.DecodeDynamicLength(buf, 1024000)
		if err != nil {
			return err
		}
		e.ParkedNodes = make([][]byte, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if len(buf) > 1024000 {
				return ssz.ErrBytesLength
			}
			if cap(e.ParkedNodes[indx]) == 0 {
				e.ParkedNodes[indx] = make([]byte, 0, len(buf))
			}
			e.ParkedNodes[indx] = append(e.ParkedNodes[indx], buf...)
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (6) 'NIP'
	{
		buf = tail[o6:]
		if e.NIP == nil {
			e.NIP = new(shared.MerkleProof)
		}
		if err = e.NIP.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the executionState object
func (e *executionState) SizeSSZ() (size int) {
	size = 33

	// Field (2) 'Members'
	for ii := 0; ii < len(e.Members); ii++ {
		size += 4
		size += len(e.Members[ii])
	}

	// Field (3) 'Statement'
	size += len(e.Statement)

	// Field (4) 'ParkedNodes'
	for ii := 0; ii < len(e.ParkedNodes); ii++ {
		size += 4
		size += len(e.ParkedNodes[ii])
	}

	// Field (6) 'NIP'
	if e.NIP == nil {
		e.NIP = new(shared.MerkleProof)
	}
	size += e.NIP.SizeSSZ()

	return
}

// MarshalSSZ ssz marshals the roundState object
func (r *roundState) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(r)
}

// MarshalSSZTo ssz marshals the roundState object to a target array
func (r *roundState) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(20)

	// Field (0) 'Opened'
	dst = ssz.MarshalUint64(dst, r.Opened)

	// Field (1) 'ExecutionStarted'
	dst = ssz.MarshalUint64(dst, r.ExecutionStarted)

	// Offset (2) 'Execution'
	dst = ssz.WriteOffset(dst, offset)
	if r.Execution == nil {
		r.Execution = new(executionState)
	}
	offset += r.Execution.SizeSSZ()

	// Field (2) 'Execution'
	if dst, err = r.Execution.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the roundState object
func (r *roundState) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 20 {
		return ssz.ErrSize
	}

	tail := buf
	var o2 uint64

	// Field (0) 'Opened'
	r.Opened = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'ExecutionStarted'
	r.ExecutionStarted = ssz.UnmarshallUint64(buf[8:16])

	// Offset (2) 'Execution'
	if o2 = ssz.ReadOffset(buf[16:20]); o2 > size {
		return ssz.ErrOffset
	}

	// Field (2) 'Execution'
	{
		buf = tail[o2:]
		if r.Execution == nil {
			r.Execution = new(executionState)
		}
		if err = r.Execution.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the roundState object
func (r *roundState) SizeSSZ() (size int) {
	size = 20

	// Field (2) 'Execution'
	if r.Execution == nil {
		r.Execution = new(executionState)
	}
	size += r.Execution.SizeSSZ()

	return
}

// MarshalSSZ ssz marshals the serviceState object
func (s *serviceState) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the serviceState object to a target array
func (s *serviceState) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(12)

	// Field (0) 'NextRoundID'
	dst = ssz.MarshalUint64(dst, s.NextRoundID)

	// Offset (1) 'PrivKey'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(s.PrivKey)

	// Field (1) 'PrivKey'
	if len(s.PrivKey) > 256 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, s.PrivKey...)

	return
}

// UnmarshalSSZ ssz unmarshals the serviceState object
func (s *serviceState) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 12 {
		return ssz.ErrSize
	}

	tail := buf
	var o1 uint64

	// Field (0) 'NextRoundID'
	s.NextRoundID = ssz.UnmarshallUint64(buf[0:8])

	// Offset (1) 'PrivKey'
	if o1 = ssz.ReadOffset(buf[8:12]); o1 > size {
		return ssz.ErrOffset
	}

	// Field (1) 'PrivKey'
	{
		buf = tail[o1:]
		if len(buf) > 256 {
			return ssz.ErrBytesLength
		}
		if cap(s.PrivKey) == 0 {
			s.PrivKey = make([]byte, 0, len(buf))
		}
		s.PrivKey = append(s.PrivKey, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the serviceState object
func (s *serviceState) SizeSSZ() (size int) {
	size = 12

	// Field (1) 'PrivKey'
	size += len(s.PrivKey)

	return
}

// MarshalSSZ ssz marshals the GossipPoetProof object
func (g *GossipPoetProof) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(g)
}

// MarshalSSZTo ssz marshals the GossipPoetProof object to a target array
func (g *GossipPoetProof) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(16)

	// Offset (0) 'MerkleProof'
	dst = ssz.WriteOffset(dst, offset)
	offset += g.MerkleProof.SizeSSZ()

	// Offset (1) 'Members'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(g.Members); ii++ {
		offset += 4
		offset += len(g.Members[ii])
	}

	// Field (2) 'NumLeaves'
	dst = ssz.MarshalUint64(dst, g.NumLeaves)

	// Field (0) 'MerkleProof'
	if dst, err = g.MerkleProof.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'Members'
	if len(g.Members) > 4096 {
		err = ssz.ErrListTooBig
		return
	}
	{
		offset = 4 * len(g.Members)
		for ii := 0; ii < len(g.Members); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += len(g.Members[ii])
		}
	}
	for ii := 0; ii < len(g.Members); ii++ {
		if len(g.Members[ii]) > 4096 {
			err = ssz.ErrBytesLength
			return
		}
		dst = append(dst, g.Members[ii]...)
	}

	return
}

// UnmarshalSSZ ssz unmarshals the GossipPoetProof object
func (g *GossipPoetProof) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 16 {
		return ssz.ErrSize
	}

	tail := buf
	var o0, o1 uint64

	// Offset (0) 'MerkleProof'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	// Offset (1) 'Members'
	if o1 = ssz.ReadOffset(buf[4:8]); o1 > size || o0 > o1 {
		return ssz.ErrOffset
	}

	// Field (2) 'NumLeaves'
	g.NumLeaves = ssz.UnmarshallUint64(buf[8:16])

	// Field (0) 'MerkleProof'
	{
		buf = tail[o0:o1]
		if err = g.MerkleProof.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}

	// Field (1) 'Members'
	{
		buf = tail[o1:]
		num, err := ssz.DecodeDynamicLength(buf, 4096)
		if err != nil {
			return err
		}
		g.Members = make([][]byte, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if len(buf) > 4096 {
				return ssz.ErrBytesLength
			}
			if cap(g.Members[indx]) == 0 {
				g.Members[indx] = make([]byte, 0, len(buf))
			}
			g.Members[indx] = append(g.Members[indx], buf...)
			return nil
		})
		if err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the GossipPoetProof object
func (g *GossipPoetProof) SizeSSZ() (size int) {
	size = 16

	// Field (0) 'MerkleProof'
	size += g.MerkleProof.SizeSSZ()

	// Field (1) 'Members'
	for ii := 0; ii < len(g.Members); ii++ {
		size += 4
		size += len(g.Members[ii])
	}

	return
}

// MarshalSSZ ssz marshals the PoetProofMessage object
func (p *PoetProofMessage) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(p)
}

// MarshalSSZTo ssz marshals the PoetProofMessage object to a target array
func (p *PoetProofMessage) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(16)

	// Offset (0) 'GossipPoetProof'
	dst = ssz.WriteOffset(dst, offset)
	offset += p.GossipPoetProof.SizeSSZ()

	// Offset (1) 'ServicePubKey'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(p.ServicePubKey)

	// Offset (2) 'RoundID'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(p.RoundID)

	// Offset (3) 'Signature'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(p.Signature)

	// Field (0) 'GossipPoetProof'
	if dst, err = p.GossipPoetProof.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'ServicePubKey'
	if len(p.ServicePubKey) > 4096 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, p.ServicePubKey...)

	// Field (2) 'RoundID'
	if len(p.RoundID) > 4096 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, []byte(p.RoundID)...)

	// Field (3) 'Signature'
	if len(p.Signature) > 4096 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, p.Signature...)

	return
}

// UnmarshalSSZ ssz unmarshals the PoetProofMessage object
func (p *PoetProofMessage) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 16 {
		return ssz.ErrSize
	}

	tail := buf
	var o0, o1, o2, o3 uint64

	// Offset (0) 'GossipPoetProof'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	// Offset (1) 'ServicePubKey'
	if o1 = ssz.ReadOffset(buf[4:8]); o1 > size || o0 > o1 {
		return ssz.ErrOffset
	}

	// Offset (2) 'RoundID'
	if o2 = ssz.ReadOffset(buf[8:12]); o2 > size || o1 > o2 {
		return ssz.ErrOffset
	}

	// Offset (3) 'Signature'
	if o3 = ssz.ReadOffset(buf[12:16]); o3 > size || o2 > o3 {
		return ssz.ErrOffset
	}

	// Field (0) 'GossipPoetProof'
	{
		buf = tail[o0:o1]
		if err = p.GossipPoetProof.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}

	// Field (1) 'ServicePubKey'
	{
		buf = tail[o1:o2]
		if len(buf) > 4096 {
			return ssz.ErrBytesLength
		}
		if cap(p.ServicePubKey) == 0 {
			p.ServicePubKey = make([]byte, 0, len(buf))
		}
		p.ServicePubKey = append(p.ServicePubKey, buf...)
	}

	// Field (2) 'RoundID'
	{
		buf = tail[o2:o3]
		if len(buf) > 4096 {
			return ssz.ErrBytesLength
		}
		p.RoundID = string(buf)
	}

	// Field (3) 'Signature'
	{
		buf = tail[o3:]
		if len(buf) > 4096 {
			return ssz.ErrBytesLength
		}
		if cap(p.Signature) == 0 {
			p.Signature = make([]byte, 0, len(buf))
		}
		p.Signature = append(p.Signature, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the PoetProofMessage object
func (p *PoetProofMessage) SizeSSZ() (size int) {
	size = 16

	// Field (0) 'GossipPoetProof'
	size += p.GossipPoetProof.SizeSSZ()

	// Field (1) 'ServicePubKey'
	size += len(p.ServicePubKey)

	// Field (2) 'RoundID'
	size += len(p.RoundID)

	// Field (3) 'Signature'
	size += len(p.Signature)

	return
}
